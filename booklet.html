<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Booklet Maker A3</title>
<style>
body { font-family: sans-serif; margin: 20px; }
textarea { width: 100%; height: 260px; margin-top: 20px; }
</style>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>
<h2>Booklet Maker (A3, client only)</h2>
<input type="file" id="file" accept="application/pdf" multiple />
<button id="go">Make Booklet</button>
<textarea id="errors" placeholder="Debug output"></textarea>

<script type="module">
import * as pdfjs from 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4.449/+esm';

function debug(msg) {
  const t = document.getElementById('errors');
  t.value += msg + "\n";
}

try {
  debug('Setting workerSrc');
  pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@5.4.449/build/pdf.worker.mjs';
} catch (e) {
  debug('WorkerSrc error: ' + e);
}

debug('pdfjs loaded: ' + typeof pdfjs);
const pdfjsLib = pdfjs;

document.getElementById('go').onclick = async () => {
  debug('Button clicked');
  const files = Array.from(document.getElementById('file').files);
  if (!files.length) {
    debug('No files selected');
    return;
  }

  for (const f of files) {
    debug('Processing file: ' + f.name);
    try {
      const buf = await f.arrayBuffer();
      // Make a copy for PDFLib so pdfjs can safely detach/transfer the original buffer
      const pdfLibBuf = buf.slice(0);
      debug('ArrayBuffer ok, loading PDF');

      let src;
      try {
        src = await pdfjsLib.getDocument({ data: buf }).promise;
        debug('PDF loaded successfully');
      } catch (e) {
        debug('getDocument failed: ' + e);
        continue;
      }

      let count = src.numPages;
      debug('Page count: ' + count);

      // Special case: a single-page PDF should pass through as-is (A4, no imposition)
      if (count === 1) {
        debug('Single page input â€“ passing through as A4');
        const orig = await PDFLib.PDFDocument.load(pdfLibBuf);
        const out = await PDFLib.PDFDocument.create();
        const [page] = await out.copyPages(orig, [0]);
        out.addPage(page);

        debug('Saving passthrough PDF');
        const bytes = await out.save();
        const blob = new Blob([bytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = f.name.replace(/\.pdf$/i, '') + '_a4.pdf';
        a.click();

        debug('Done with single-page file');
        continue;
      }

      function imposedPairs(n) {
        if (n === 2) return [[1, 0]];
        const pad = n % 4 === 0 ? 0 : 4 - (n % 4);
        const total = n + pad;
        const arr = [];
        let L = 0;
        let R = total - 1;
        while (L < R) {
          arr.push([R, L]);
          L++; R--;
          arr.push([L, R]);
          L++; R--;
        }
        return arr;
      }

      const out = await PDFLib.PDFDocument.create();
      const A3w = 1190.55;
      const A3h = 841.89;

      const rendered = [];
      const baseName = f.name.replace(/\.pdf$/i, '');
      const coverLabel = baseName.replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim() || baseName || 'Booklet';
      for (let i = 1; i <= count; i++) {
        debug('Rendering page ' + i);
        const p = await src.getPage(i);
        const viewport = p.getViewport({ scale: 2 });
        const c = document.createElement('canvas');
        c.width = viewport.width;
        c.height = viewport.height;
        const ctx = c.getContext('2d');
        await p.render({ canvasContext: ctx, viewport }).promise;
        rendered.push(c);
        debug('Rendered page ' + i);
      }

      if (count === 2) {
        debug('Inserting cover page for two-page input');
        const template = rendered[0] || rendered[1];
        const coverCanvas = document.createElement('canvas');
        coverCanvas.width = template ? template.width : 1190;
        coverCanvas.height = template ? template.height : 842;
        const coverCtx = coverCanvas.getContext('2d');
        coverCtx.fillStyle = '#ffffff';
        coverCtx.fillRect(0, 0, coverCanvas.width, coverCanvas.height);
        coverCtx.fillStyle = '#000000';
        coverCtx.textAlign = 'center';
        coverCtx.textBaseline = 'middle';

        // Auto-shrink font size so long titles still fit inside the page
        const maxWidth = coverCanvas.width * 0.8;
        let fontSize = Math.min(coverCanvas.width, coverCanvas.height) * 0.15;
        while (fontSize > 10) {
          coverCtx.font = `bold ${fontSize}px sans-serif`;
          const metrics = coverCtx.measureText(coverLabel);
          if (metrics.width <= maxWidth) break;
          fontSize -= 2;
        }

        coverCtx.fillText(coverLabel, coverCanvas.width / 2, coverCanvas.height / 2);
        rendered.unshift(coverCanvas);
        count = rendered.length;
      }

      const pairs = count === 1 ? [[0, -1]] : imposedPairs(count);
      debug('Pairs: ' + JSON.stringify(pairs));

      debug('Creating imposed output pages');

      for (let i = 0; i < pairs.length; i++) {
        const [L, R] = pairs[i];
        const page = out.addPage([A3w, A3h]);

        if (L >= 0 && L < count) {
          debug('Drawing left page ' + L);
          const img = await out.embedPng(rendered[L].toDataURL());
          const s = A3h / img.height;
          page.drawImage(img, { x: 0, y: 0, width: img.width * s, height: img.height * s });
        }

        if (R >= 0 && R < count) {
          debug('Drawing right page ' + R);
          const img = await out.embedPng(rendered[R].toDataURL());
          const s = A3h / img.height;
          page.drawImage(img, { x: A3w / 2, y: 0, width: img.width * s, height: img.height * s });
        }

        // This sets the page rotation metadata for printing
        if (i % 2 === 1) {
          page.setRotation(PDFLib.degrees(180));
        }
      }

      debug('Saving PDF');
      const bytes = await out.save();
      const blob = new Blob([bytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = f.name.replace(/\.pdf$/i, '') + '_booklet.pdf';
      a.click();

      debug('Done with file');

    } catch (e) {
      debug('Fatal error: ' + e);
    }
  }
};
</script>
</body>
</html>
